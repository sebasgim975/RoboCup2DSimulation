#include "dialog.h"
#include "./ui_dialog.h"
#include "Ball.h"
#include <QGraphicsPixmapItem>
#include "team.h"
#include <QDebug>
#include <QVBoxLayout>
#include <QMessageBox>
#include "player.h"

#include "dialog.h"
#include <QBrush>

// Constructor of the Dialog class, initializes the dialog window with the game scene.
Dialog::Dialog(QWidget *parent)
    : QDialog(parent), ui(new Ui::Dialog), scene(new QGraphicsScene(this)), gameSecondsElapsed(0)
{
    ui->setupUi(this);  // Sets up the user interface as generated by Qt Designer.
    ui->graphicsView->setScene(scene);  // Sets the game scene in the graphic view.
    ui->graphicsView->setRenderHint(QPainter::Antialiasing);  // Enables antialiasing to improve rendering quality.

    int width = ui->graphicsView->width();  // Gets the width of the graphic area.
    int height = ui->graphicsView->height();  // Gets the height of the graphic area.

    QPixmap background("C:/Users/sebas/OneDrive/Documents/RoboCupSoccer/soccer-field.jpg");  // Loads the background image of the soccer field.
    if (!background.isNull()) {
        QGraphicsPixmapItem* backgroundItem = scene->addPixmap(background);  // Adds the image to the background of the scene.
        backgroundItem->setZValue(-1);  // Sets the layer order of the background to be behind all objects.
        backgroundItem->setPos(0, 0);  // Positions the image at the top left of the scene.
        backgroundItem->setScale(1.0);  // Sets the scale of the image.
    } else {
        qDebug() << "Background image not found";  // Displays an error message if the image is not loaded.
    }

    // Goal configuration
    int goalHeight = 30;  // Height of the goals.
    int goalWidth = 10;  // Width of the goals.
    QGraphicsRectItem *goal1 = new QGraphicsRectItem(0, 0, goalWidth, goalHeight);  // Creates the rectangle for goal 1.
    goal1->setPos((width - 1.8 * goalWidth), height / 2 - goalHeight / 2);  // Positions goal 1.
    goal1->setData(0, "goal1");  // Sets the identifier for goal 1.
    goal1->setPen(Qt::NoPen);  // Removes the border of the goal.
    goal1->setBrush(Qt::NoBrush);  // Removes the filling of the goal.
    scene->addItem(goal1);  // Adds goal 1 to the scene.

    QGraphicsRectItem *goal2 = new QGraphicsRectItem(0, 0, goalWidth, goalHeight);  // Creates the rectangle for goal 2.
    goal2->setPos((1.8 * goalWidth - goalWidth), height / 2 - goalHeight / 2);  // Positions goal 2.
    goal2->setData(0, "goal2");  // Sets the identifier for goal 2.
    goal2->setPen(Qt::NoPen);  // Removes the border of the goal.
    goal2->setBrush(Qt::NoBrush);  // Removes the filling of the goal.
    scene->addItem(goal2);  // Adds goal 2 to the scene.

    ball = new Ball(ui->graphicsView->scene());  // Creates the game ball.
    ui->graphicsView->scene()->addItem(ball);  // Adds the ball to the scene.

    // Connects the signals of goals reached to the scoring functions.
    QObject::connect(ball, SIGNAL(goal1Reached()), this, SLOT(AddGoal1Score()));
    QObject::connect(ball, SIGNAL(goal2Reached()), this, SLOT(AddGoal2Score()));

    // Connects the goal scored signal to the player reset function.
    QObject::connect(ball, &Ball::goalScored, this, &Dialog::resetPlayers);

    // Creates and initializes the teams.
    team1 = new Team(scene, ball);
    team1->initializePlayers(scene, ball, Qt::white, 50, 1);
    team2 = new Team(scene, ball);
    team2->initializePlayers(scene, ball, Qt::black, scene->width() - 50, -1);

    // Timer to update the game clock.
    gameClockTimer = new QTimer(this);
    connect(gameClockTimer, &QTimer::timeout, this, &Dialog::updateGameClock);
    gameClockTimer->start(1000); // Updates every second.

    // Timer to update the game.
    timer = new QTimer(this);
    connect(timer, &QTimer::timeout, this, &Dialog::updateGame);
    timer->start(30); // Standard update interval.
}


// Destructor of the Dialog class, responsible for releasing allocated resources.
Dialog::~Dialog()
{
    delete ui;       // Releases the user interface.
    delete team1;    // Releases team1.
    delete team2;    // Releases team2.
    delete ball;     // Releases the ball.
}

// Increments the score of team1 and updates the display.
void Dialog::AddGoal1Score() {
    Goal1Score++;                                 // Increments the score of team1.
    ui->lcdNumber->display(Goal1Score);           // Displays the new score on the display.
    resetPlayers();                               // Resets the positions of the players.
}

// Increments the score of team2 and updates the display.
void Dialog::AddGoal2Score() {
    Goal2Score++;                                 // Increments the score of team2.
    ui->lcdNumber_2->display(Goal2Score);         // Displays the new score on the display.
    resetPlayers();                               // Resets the positions of the players.
}

// Updates the state of the game each frame.
void Dialog::updateGame() {
    try {
        if (scene) {
            std::vector<Player*> allPlayers;  // Vector to store all players for processing.

            // Adds players from the teams to the vector.
            auto addPlayers = [&allPlayers](const std::vector<std::unique_ptr<Player>>& team) {
                for (const auto& player : team) {
                    allPlayers.push_back(player.get());
                }
            };

            addPlayers(team1->getPlayers());  // Adds players from team1.
            addPlayers(team2->getPlayers());  // Adds players from team2.

            if (team1) team1->updateTeam(allPlayers);  // Updates team1.
            if (team2) team2->updateTeam(allPlayers);  // Updates team2.

            ball->move();  // Moves the ball.
            scene->update();  // Updates the graphic scene.
        } else {
            qDebug() << "Scene object is null, update ignored";  // Logs error if the scene does not exist.
        }
    } catch (const std::exception& e) {
        qDebug() << "Exception caught during game update:" << e.what();  // Logs captured exceptions.
    } catch (...) {
        qDebug() << "An unknown error occurred during game update";  // Captures unspecified errors.
    }
}

// Resets the position of all players in the teams.
void Dialog::resetPlayers() {
    for (auto& player : team1->getPlayers()) {
        player->resetPosition();  // Resets the position of team1 players.
    }
    for (auto& player : team2->getPlayers()) {
        player->resetPosition();  // Resets the position of team2 players.
    }
}

// Updates the game clock every second.
void Dialog::updateGameClock() {
    gameSecondsElapsed++;  // Increments the seconds counter.
    int minutes = gameSecondsElapsed / 60;  // Calculates the minutes passed.
    int seconds = gameSecondsElapsed % 60;  // Calculates the seconds passed.
    QString timeText = QString("%1:%2").arg(minutes, 2, 10, QChar('0')).arg(seconds, 2, 10, QChar('0'));
    ui->gameClockDisplay->display(timeText);  // Displays the time on the display.

    if (gameSecondsElapsed >= 300) {  // If 5 minutes have passed, stop the clock.
        gameClockTimer->stop();
        QString message = QString("5 minutes have passed. The game is over.\nFinal Score:\nTeam 1: %1\nTeam 2: %2")
                              .arg(Goal1Score)
                              .arg(Goal2Score);
        QMessageBox msgBox;  // Creates a message box.
        msgBox.setText(message);  // Sets the message text.
        msgBox.exec();  // Displays the message.
        close();  // Closes the dialog window after the message is dismissed.
    }
}
